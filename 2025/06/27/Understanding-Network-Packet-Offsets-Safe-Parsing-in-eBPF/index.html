<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="Continuing our series on systems programming, last time we built a syscall logger. Today, we’re going deeper into the network stack with a network packet parser using eBPF and Rust. This logic is the">
<meta property="og:type" content="article">
<meta property="og:title" content="Understanding Network Packet Offsets &amp; Safe Parsing in eBPF">
<meta property="og:url" content="https://diobr4nd0.github.io/2025/06/27/Understanding-Network-Packet-Offsets-Safe-Parsing-in-eBPF/index.html">
<meta property="og:site_name" content="Dio&#39;s Blogs">
<meta property="og:description" content="Continuing our series on systems programming, last time we built a syscall logger. Today, we’re going deeper into the network stack with a network packet parser using eBPF and Rust. This logic is the">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://diobr4nd0.github.io/images/xdp_output.png">
<meta property="article:published_time" content="2025-06-27T18:26:09.000Z">
<meta property="article:modified_time" content="2025-06-27T19:47:15.822Z">
<meta property="article:author" content="Rupesh Prajapati">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://diobr4nd0.github.io/images/xdp_output.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>Understanding Network Packet Offsets &amp; Safe Parsing in eBPF</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 7.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="https://github.com/DioBr4nd0">Projects</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        
        <li><a class="icon" aria-label="Next post" href="/2025/06/21/Track-Linux-Syscalls-with-Rust-and-eBPF/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://diobr4nd0.github.io/2025/06/27/Understanding-Network-Packet-Offsets-Safe-Parsing-in-eBPF/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://diobr4nd0.github.io/2025/06/27/Understanding-Network-Packet-Offsets-Safe-Parsing-in-eBPF/&text=Understanding Network Packet Offsets &amp; Safe Parsing in eBPF"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://diobr4nd0.github.io/2025/06/27/Understanding-Network-Packet-Offsets-Safe-Parsing-in-eBPF/&title=Understanding Network Packet Offsets &amp; Safe Parsing in eBPF"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://diobr4nd0.github.io/2025/06/27/Understanding-Network-Packet-Offsets-Safe-Parsing-in-eBPF/&is_video=false&description=Understanding Network Packet Offsets &amp; Safe Parsing in eBPF"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Understanding Network Packet Offsets &amp; Safe Parsing in eBPF&body=Check out this article: https://diobr4nd0.github.io/2025/06/27/Understanding-Network-Packet-Offsets-Safe-Parsing-in-eBPF/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://diobr4nd0.github.io/2025/06/27/Understanding-Network-Packet-Offsets-Safe-Parsing-in-eBPF/&title=Understanding Network Packet Offsets &amp; Safe Parsing in eBPF"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://diobr4nd0.github.io/2025/06/27/Understanding-Network-Packet-Offsets-Safe-Parsing-in-eBPF/&title=Understanding Network Packet Offsets &amp; Safe Parsing in eBPF"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://diobr4nd0.github.io/2025/06/27/Understanding-Network-Packet-Offsets-Safe-Parsing-in-eBPF/&title=Understanding Network Packet Offsets &amp; Safe Parsing in eBPF"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://diobr4nd0.github.io/2025/06/27/Understanding-Network-Packet-Offsets-Safe-Parsing-in-eBPF/&title=Understanding Network Packet Offsets &amp; Safe Parsing in eBPF"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://diobr4nd0.github.io/2025/06/27/Understanding-Network-Packet-Offsets-Safe-Parsing-in-eBPF/&name=Understanding Network Packet Offsets &amp; Safe Parsing in eBPF&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://diobr4nd0.github.io/2025/06/27/Understanding-Network-Packet-Offsets-Safe-Parsing-in-eBPF/&t=Understanding Network Packet Offsets &amp; Safe Parsing in eBPF"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#What-is-a-Network-Packet-Parser"><span class="toc-number">1.</span> <span class="toc-text">What is a Network Packet Parser?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Some-Basic-Concepts"><span class="toc-number">2.</span> <span class="toc-text">Some Basic Concepts</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%F0%9F%93%A6-What-is-a-packet"><span class="toc-number">2.1.</span> <span class="toc-text">1. 📦 What is a packet?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%F0%9F%A7%AE-What-is-an-offset"><span class="toc-number">2.2.</span> <span class="toc-text">2. 🧮 What is an offset?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%F0%9F%A7%B7-Accessing-via-pointers"><span class="toc-number">2.3.</span> <span class="toc-text">3. 🧷 Accessing via pointers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%F0%9F%A7%BE-The-packet-memory-range"><span class="toc-number">2.4.</span> <span class="toc-text">4. 🧾 The packet memory range</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-Full-Explanation-of-ptr-at"><span class="toc-number">2.5.</span> <span class="toc-text">✅ Full Explanation of ptr_at()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%92%A1-Example-Reading-the-IPv4-Header"><span class="toc-number">2.5.1.</span> <span class="toc-text">💡 Example: Reading the IPv4 Header</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%94%92-Why-all-this-checking"><span class="toc-number">2.5.2.</span> <span class="toc-text">🔒 Why all this checking?</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#What-is-XDP"><span class="toc-number">3.</span> <span class="toc-text">What is XDP?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Setting-Up-the-Codebase"><span class="toc-number">4.</span> <span class="toc-text">Setting Up the Codebase</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Main-Packet-Parsing-Logic"><span class="toc-number">5.</span> <span class="toc-text">Main Packet Parsing Logic</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Get-the-IPv4-packets-from-the-input-packet-stream"><span class="toc-number">5.1.</span> <span class="toc-text">1. Get the IPv4 packets from the input packet stream</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Extracting-and-Logging-Parameters"><span class="toc-number">5.2.</span> <span class="toc-text">2. Extracting and Logging Parameters</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-The-ptr-at-Helper"><span class="toc-number">5.3.</span> <span class="toc-text">3. The ptr_at Helper</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-The-XDP-Firewall-Entry-Point"><span class="toc-number">5.4.</span> <span class="toc-text">4. The XDP Firewall Entry Point</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Putting-It-All-Together"><span class="toc-number">5.5.</span> <span class="toc-text">5. Putting It All Together</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Loading-and-Attaching-the-Program"><span class="toc-number">6.</span> <span class="toc-text">Loading and Attaching the Program</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Building-and-Running"><span class="toc-number">7.</span> <span class="toc-text">Building and Running</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Congratulations"><span class="toc-number">8.</span> <span class="toc-text">Congratulations!</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Follow-like-repost-comment"><span class="toc-number">9.</span> <span class="toc-text">Follow ,like ,repost ,comment</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#References"><span class="toc-number">10.</span> <span class="toc-text">References</span></a></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        Understanding Network Packet Offsets &amp; Safe Parsing in eBPF
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">Rupesh Prajapati</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2025-06-27T18:26:09.000Z" class="dt-published" itemprop="datePublished">2025-06-27</time>
        
      
    </div>


      

      

    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <p>Continuing our series on systems programming, last time we built a syscall logger. Today, we’re going deeper into the network stack with a <strong>network packet parser</strong> using eBPF and Rust. This logic is the backbone of modern network observability, security, and performance tools. By the end, you’ll understand how to safely extract protocol fields from raw packets at kernel speed—and how this foundation can be extended to build firewalls, traffic monitors, or even protocol analyzers.</p>
<hr>
<h2 id="What-is-a-Network-Packet-Parser"><a href="#What-is-a-Network-Packet-Parser" class="headerlink" title="What is a Network Packet Parser?"></a>What is a Network Packet Parser?</h2><p>A <strong>network packet parser</strong> is a piece of code that inspects the raw bytes of a network packet as it moves through the system. Its job is to:</p>
<ul>
<li>Identify protocol headers (Ethernet, IP, TCP&#x2F;UDP, etc.)</li>
<li>Extract fields (like source&#x2F;destination IPs and ports)</li>
<li>Make decisions (log, drop, redirect, etc.) based on packet contents</li>
</ul>
<p><strong>Uses:</strong><br>Packet parsers are used in firewalls, intrusion detection systems, traffic monitoring, and performance analytics. In this tutorial, we’ll focus on parsing Ethernet, IPv4, TCP, and UDP headers safely in eBPF. This logic can be extended to support more protocols, build advanced filters, or even modify packets in flight.</p>
<hr>
<h2 id="Some-Basic-Concepts"><a href="#Some-Basic-Concepts" class="headerlink" title="Some Basic Concepts"></a>Some Basic Concepts</h2><p>Let’s break down the core ideas behind packet parsing in eBPF, as simply as possible:</p>
<h3 id="1-📦-What-is-a-packet"><a href="#1-📦-What-is-a-packet" class="headerlink" title="1. 📦 What is a packet?"></a>1. 📦 What is a packet?</h3><p>A network packet is just a chunk of bytes moving through your network card. It usually looks like this:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----------------+----------------+--------------------+</span><br><span class="line">| Ethernet Header| IP Header | TCP/UDP Header |         |</span><br><span class="line">+----------------+----------------+--------------------+</span><br><span class="line">0               14          34              ~54         |</span><br><span class="line">+----------------+----------------+--------------------+</span><br></pre></td></tr></table></figure>


<p>Each protocol has a fixed-size header, and the data starts at a certain <strong>offset</strong> (position) from the beginning of the packet.</p>
<hr>
<h3 id="2-🧮-What-is-an-offset"><a href="#2-🧮-What-is-an-offset" class="headerlink" title="2. 🧮 What is an offset?"></a>2. 🧮 What is an offset?</h3><p>An <strong>offset</strong> is “how many bytes from the start of the packet do we want to look at?”</p>
<ul>
<li>Ethernet header is 14 bytes → IP starts at offset 14</li>
<li>IP header is 20 bytes → TCP starts at offset 14 + 20 &#x3D; 34</li>
</ul>
<p>So:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">offset = <span class="number">14</span> (Ethernet) + <span class="number">20</span> (IP) = <span class="number">34</span></span><br></pre></td></tr></table></figure>


<hr>
<h3 id="3-🧷-Accessing-via-pointers"><a href="#3-🧷-Accessing-via-pointers" class="headerlink" title="3. 🧷 Accessing via pointers"></a>3. 🧷 Accessing via pointers</h3><p>In kernel space (like eBPF), we don’t get structs like <code>Ipv4Hdr</code> directly.<br>Instead, we get access to the raw memory (bytes) of the packet.<br>We have to manually cast bytes at the right offset into the right struct (<code>EthHdr</code>, <code>Ipv4Hdr</code>, etc.).</p>
<p>But we <strong>can’t just blindly read memory</strong>.<br>The eBPF verifier wants to make sure we don’t read beyond packet bounds.</p>
<hr>
<h3 id="4-🧾-The-packet-memory-range"><a href="#4-🧾-The-packet-memory-range" class="headerlink" title="4. 🧾 The packet memory range"></a>4. 🧾 The packet memory range</h3><p>The packet is in memory between two pointers:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctx.data() // start of packet</span><br><span class="line">ctx.data_end() // end of packet</span><br></pre></td></tr></table></figure>


<p>So, to safely read <code>T</code> bytes from offset <code>N</code>, we must check:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.<span class="title function_ invoke__">data</span>() + N + size_of::&lt;T&gt;() &lt;= ctx.<span class="title function_ invoke__">data_end</span>()</span><br></pre></td></tr></table></figure>


<p>This ensures we’re not reading beyond the memory the packet provides.</p>
<hr>
<h3 id="✅-Full-Explanation-of-ptr-at"><a href="#✅-Full-Explanation-of-ptr-at" class="headerlink" title="✅ Full Explanation of ptr_at()"></a>✅ Full Explanation of <code>ptr_at()</code></h3><p>Here’s the safe pointer helper:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[inline(always)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">ptr_at</span>&lt;T&gt;(ctx: &amp;XdpContext, offset:<span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;*<span class="keyword">const</span> T, ()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">start</span> = ctx.<span class="title function_ invoke__">data</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">end</span> = ctx.<span class="title function_ invoke__">data_end</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">len</span> = mem::size_of::&lt;T&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> start + offset + len &gt; end &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>((start + offset) <span class="keyword">as</span> *<span class="keyword">const</span> T)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>What it does:</strong></p>
<ul>
<li>Gets start and end of the packet memory</li>
<li>Gets the size of the struct you want to read (e.g., Ethernet header &#x3D; 14 bytes)</li>
<li>Checks if it’s safe to read that struct from the given offset</li>
<li>If safe, returns a pointer to that location</li>
</ul>
<p>This pointer is still unsafe to read, but now it’s verifier-approved!</p>
<hr>
<h4 id="💡-Example-Reading-the-IPv4-Header"><a href="#💡-Example-Reading-the-IPv4-Header" class="headerlink" title="💡 Example: Reading the IPv4 Header"></a>💡 Example: Reading the IPv4 Header</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">ipv4hdr</span>: *<span class="keyword">const</span> Ipv4Hdr = <span class="title function_ invoke__">ptr_at</span>(&amp;ctx, EthHdr::LEN)?;</span><br></pre></td></tr></table></figure>

<p>This means: “start reading an <code>Ipv4Hdr</code> at offset 14”.<br>If it’s safe, you get a pointer to the IPv4 header.</p>
<hr>
<h4 id="🔒-Why-all-this-checking"><a href="#🔒-Why-all-this-checking" class="headerlink" title="🔒 Why all this checking?"></a>🔒 Why all this checking?</h4><p>In kernel-space, safety is critical.<br>If your program tries to read memory it shouldn’t, the eBPF verifier will reject it.<br>So <code>ptr_at</code> makes sure you only read what’s inside the actual packet.</p>
<hr>
<p><strong>In simple words:</strong><br><code>ptr_at&lt;T&gt;(ctx, offset)</code> &#x3D; “Give me a pointer to a struct T located at <code>offset</code> bytes from the start of the packet — but only if that memory is inside the packet’s bounds.”</p>
<hr>
<h2 id="What-is-XDP"><a href="#What-is-XDP" class="headerlink" title="What is XDP?"></a>What is XDP?</h2><p><strong>XDP (eXpress Data Path)</strong> is a high-performance packet processing framework in the Linux kernel, powered by eBPF. It allows you to run custom programs at the earliest possible point in the network stack—right as packets arrive from the NIC.<br>This means you can inspect, filter, or redirect packets with minimal latency, making XDP ideal for firewalls, DDoS mitigation, and advanced monitoring.</p>
<hr>
<h2 id="Setting-Up-the-Codebase"><a href="#Setting-Up-the-Codebase" class="headerlink" title="Setting Up the Codebase"></a>Setting Up the Codebase</h2><p>If you haven’t set up your development environment yet, please refer to the previous blog:<br><a href="https://diobr4nd0.github.io/2025/06/21/Track-Linux-Syscalls-with-Rust-and-eBPF/">Track Linux Syscalls with Rust and eBPF</a></p>
<p>To start, follow the Rust eBPF development setup instructions provided by the Aya project.</p>
<p><strong>Generate a new eBPF project template:</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo generate -a aya-rs/aya-template -n xdp_packet_parser</span><br></pre></td></tr></table></figure>


<ul>
<li>Select <strong>xdp</strong> as the type of eBPF program when prompted.</li>
</ul>
<hr>
<h2 id="Main-Packet-Parsing-Logic"><a href="#Main-Packet-Parsing-Logic" class="headerlink" title="Main Packet Parsing Logic"></a>Main Packet Parsing Logic</h2><p>Let’s walk through the key steps of our XDP packet parser.</p>
<h3 id="1-Get-the-IPv4-packets-from-the-input-packet-stream"><a href="#1-Get-the-IPv4-packets-from-the-input-packet-stream" class="headerlink" title="1. Get the IPv4 packets from the input packet stream"></a>1. Get the IPv4 packets from the input packet stream</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">ethhdr</span>: *<span class="keyword">const</span> EthHdr = <span class="title function_ invoke__">ptr_at</span>(&amp;ctx, <span class="number">0</span>)?;</span><br><span class="line"><span class="keyword">match</span> <span class="keyword">unsafe</span> &#123; (*ethhdr).ether_type &#125; &#123;</span><br><span class="line">EtherType::Ipv4 =&gt; &#123;&#125;,</span><br><span class="line">_ =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Ok</span>(xdp_action::XDP_PASS),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>Extract the Ethernet header at offset 0.</li>
<li>If the EtherType is IPv4, continue parsing; otherwise, let the packet pass.</li>
</ul>
<hr>
<h3 id="2-Extracting-and-Logging-Parameters"><a href="#2-Extracting-and-Logging-Parameters" class="headerlink" title="2. Extracting and Logging Parameters"></a>2. Extracting and Logging Parameters</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">try_xdp_firewall</span>(ctx: XdpContext) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">u32</span>, ()&gt; &#123;</span><br><span class="line">    <span class="comment">// Extract Ethernet header</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ethhdr</span>: *<span class="keyword">const</span> EthHdr = <span class="title function_ invoke__">ptr_at</span>(&amp;ctx, <span class="number">0</span>)?;</span><br><span class="line">    <span class="comment">// Available Ethernet parameters:</span></span><br><span class="line">    <span class="comment">// let src_mac = unsafe &#123; (*ethhdr).src_addr &#125;;  // Source MAC address [u8; 6]</span></span><br><span class="line">    <span class="comment">// let dst_mac = unsafe &#123; (*ethhdr).dst_addr &#125;;  // Destination MAC address [u8; 6]</span></span><br><span class="line">    <span class="keyword">match</span> <span class="keyword">unsafe</span> &#123; (*ethhdr).ether_type&#125; &#123;</span><br><span class="line">        EtherType::Ipv4 =&gt; &#123;&#125;,</span><br><span class="line">        _ =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Ok</span>(xdp_action::XDP_PASS),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Extract IPv4 header</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ipc4hdr</span>: *<span class="keyword">const</span> Ipv4Hdr = <span class="title function_ invoke__">ptr_at</span>(&amp;ctx, EthHdr::LEN)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">source_addr</span> = <span class="type">u32</span>::<span class="title function_ invoke__">from_be_bytes</span>(<span class="keyword">unsafe</span> &#123; (*ipc4hdr).src_addr &#125;);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">dest_addr</span> = <span class="type">u32</span>::<span class="title function_ invoke__">from_be_bytes</span>(<span class="keyword">unsafe</span> &#123; (*ipc4hdr).dst_addr &#125;);</span><br><span class="line">    <span class="comment">// Available IPv4 parameters:</span></span><br><span class="line">    <span class="comment">// let ttl = unsafe &#123; (*ipc4hdr).ttl &#125;;         // Time To Live</span></span><br><span class="line">    <span class="comment">// let tos = unsafe &#123; (*ipc4hdr).tos &#125;;         // Type of Service</span></span><br><span class="line">    <span class="comment">// let tot_len = u16::from_be(unsafe &#123; (*ipc4hdr).tot_len &#125;); // Total Length</span></span><br><span class="line">    <span class="comment">// let id = u16::from_be(unsafe &#123; (*ipc4hdr).id &#125;);           // Identification</span></span><br><span class="line">    <span class="comment">// let frag_off = unsafe &#123; (*ipc4hdr).frag_off &#125;;             // Fragment Offset</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (source_port, dest_port) = <span class="keyword">match</span> <span class="keyword">unsafe</span> &#123; (*ipc4hdr).proto&#125; &#123;</span><br><span class="line">        IpProto::Tcp =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">tcphdr</span>: *<span class="keyword">const</span> TcpHdr = <span class="title function_ invoke__">ptr_at</span>(&amp;ctx, EthHdr::LEN + Ipv4Hdr::LEN)?;</span><br><span class="line">            <span class="comment">// Available TCP parameters:</span></span><br><span class="line">            <span class="comment">// let seq = u32::from_be(unsafe &#123; (*tcphdr).seq &#125;);     // Sequence Number</span></span><br><span class="line">            <span class="comment">// let ack = u32::from_be(unsafe &#123; (*tcphdr).ack_seq &#125;); // Acknowledgment Number</span></span><br><span class="line">            <span class="comment">// let window = u16::from_be(unsafe &#123; (*tcphdr).window &#125;); // Window Size</span></span><br><span class="line">            <span class="comment">// let flags = unsafe &#123; (*tcphdr).flags &#125;;               // TCP Flags (SYN, ACK, etc)</span></span><br><span class="line">            (</span><br><span class="line">                <span class="type">u16</span>::<span class="title function_ invoke__">from_be</span>(<span class="keyword">unsafe</span> &#123; (*tcphdr).source &#125;),</span><br><span class="line">                <span class="type">u16</span>::<span class="title function_ invoke__">from_be</span>(<span class="keyword">unsafe</span> &#123; (*tcphdr).dest &#125;)</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">        IpProto::Udp =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">udphdr</span>: *<span class="keyword">const</span> UdpHdr = <span class="title function_ invoke__">ptr_at</span>(&amp;ctx, EthHdr::LEN + Ipv4Hdr::LEN)?;</span><br><span class="line">            <span class="comment">// Available UDP parameters:</span></span><br><span class="line">            <span class="comment">// let length = u16::from_be(unsafe &#123; (*udphdr).len &#125;);  // UDP datagram length</span></span><br><span class="line">            <span class="comment">// let checksum = u16::from_be(unsafe &#123; (*udphdr).check &#125;); // Checksum</span></span><br><span class="line">            (</span><br><span class="line">                <span class="type">u16</span>::<span class="title function_ invoke__">from_be_bytes</span>(<span class="keyword">unsafe</span> &#123; (*udphdr).source &#125;),</span><br><span class="line">                <span class="type">u16</span>::<span class="title function_ invoke__">from_be_bytes</span>(<span class="keyword">unsafe</span> &#123; (*udphdr).dest &#125;)</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">        _ =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(()),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    info!(</span><br><span class="line">        &amp;ctx, </span><br><span class="line">        <span class="string">&quot;SRC IP: &#123;:i&#125;, SRC PORT: &#123;&#125;, DST IP: &#123;:i&#125;, DST PORT: &#123;&#125;&quot;</span>, </span><br><span class="line">        source_addr, </span><br><span class="line">        source_port,</span><br><span class="line">        dest_addr,</span><br><span class="line">        dest_port</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(xdp_action::XDP_PASS)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>Extract and log Ethernet, IP, and TCP&#x2F;UDP header fields.</li>
<li>This is the foundation for building firewalls, traffic counters, or protocol analyzers.</li>
</ul>
<hr>
<h3 id="3-The-ptr-at-Helper"><a href="#3-The-ptr-at-Helper" class="headerlink" title="3. The ptr_at Helper"></a>3. The <code>ptr_at</code> Helper</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[inline(always)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">ptr_at</span>&lt;T&gt;(ctx: &amp;XdpContext, offset:<span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;*<span class="keyword">const</span> T, ()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">start</span> = ctx.<span class="title function_ invoke__">data</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">end</span> = ctx.<span class="title function_ invoke__">data_end</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">len</span> = mem::size_of::&lt;T&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> start + offset + len &gt; end &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>((start + offset) <span class="keyword">as</span> *<span class="keyword">const</span> T)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>Ensures you only read memory within the packet’s bounds.</li>
<li>Returns a pointer to the struct at the given offset, or an error if out-of-bounds.</li>
</ul>
<hr>
<h3 id="4-The-XDP-Firewall-Entry-Point"><a href="#4-The-XDP-Firewall-Entry-Point" class="headerlink" title="4. The XDP Firewall Entry Point"></a>4. The XDP Firewall Entry Point</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[xdp]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">xdp_firewall</span>(ctx: XdpContext) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> <span class="title function_ invoke__">try_xdp_firewall</span>(ctx) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(ret) =&gt; ret,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(_) =&gt; xdp_action::XDP_ABORTED,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Calls the parser and returns either the XDP action or aborts on error.</li>
</ul>
<hr>
<h3 id="5-Putting-It-All-Together"><a href="#5-Putting-It-All-Together" class="headerlink" title="5. Putting It All Together"></a>5. Putting It All Together</h3><p>Here’s the complete eBPF program:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// inside xdp_packet_parser/xdp_packet_parser-ebpf/src/main.rs</span></span><br><span class="line"><span class="meta">#![no_std]</span></span><br><span class="line"><span class="meta">#![no_main]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> aya_ebpf::&#123;bindings::xdp_action, macros::xdp, programs::XdpContext&#125;;</span><br><span class="line"><span class="keyword">use</span> aya_log_ebpf::info;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> core::mem;</span><br><span class="line"><span class="keyword">use</span> network_types::&#123;</span><br><span class="line">    eth::&#123;EthHdr, EtherType&#125;,</span><br><span class="line">    ip::&#123;IpProto, Ipv4Hdr&#125;,</span><br><span class="line">    tcp::TcpHdr,</span><br><span class="line">    udp::UdpHdr,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(not(test))]</span></span><br><span class="line"><span class="meta">#[panic_handler]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">panic</span>(_info: &amp;core::panic::PanicInfo) <span class="punctuation">-&gt;</span> !&#123;</span><br><span class="line">    <span class="keyword">loop</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[xdp]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">xdp_firewall</span>(ctx: XdpContext) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> <span class="title function_ invoke__">try_xdp_firewall</span>(ctx) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(ret) =&gt; ret,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(_) =&gt; xdp_action::XDP_ABORTED,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[inline(always)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">ptr_at</span>&lt;T&gt;(ctx: &amp;XdpContext, offset:<span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;*<span class="keyword">const</span> T, ()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">start</span> = ctx.<span class="title function_ invoke__">data</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">end</span> = ctx.<span class="title function_ invoke__">data_end</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">len</span> = mem::size_of::&lt;T&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> start + offset + len &gt; end &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>((start + offset) <span class="keyword">as</span> *<span class="keyword">const</span> T)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">try_xdp_firewall</span>(ctx: XdpContext) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">u32</span>, ()&gt; &#123;</span><br><span class="line">    <span class="comment">// Extract Ethernet header</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ethhdr</span>: *<span class="keyword">const</span> EthHdr = <span class="title function_ invoke__">ptr_at</span>(&amp;ctx, <span class="number">0</span>)?;</span><br><span class="line">    <span class="comment">// Available Ethernet parameters:</span></span><br><span class="line">    <span class="comment">// let src_mac = unsafe &#123; (*ethhdr).src_addr &#125;;  // Source MAC address [u8; 6]</span></span><br><span class="line">    <span class="comment">// let dst_mac = unsafe &#123; (*ethhdr).dst_addr &#125;;  // Destination MAC address [u8; 6]</span></span><br><span class="line">    <span class="keyword">match</span> <span class="keyword">unsafe</span> &#123; (*ethhdr).ether_type&#125; &#123;</span><br><span class="line">        EtherType::Ipv4 =&gt; &#123;&#125;,</span><br><span class="line">        _ =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Ok</span>(xdp_action::XDP_PASS),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Extract IPv4 header</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ipc4hdr</span>: *<span class="keyword">const</span> Ipv4Hdr = <span class="title function_ invoke__">ptr_at</span>(&amp;ctx, EthHdr::LEN)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">source_addr</span> = <span class="type">u32</span>::<span class="title function_ invoke__">from_be_bytes</span>(<span class="keyword">unsafe</span> &#123; (*ipc4hdr).src_addr &#125;);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">dest_addr</span> = <span class="type">u32</span>::<span class="title function_ invoke__">from_be_bytes</span>(<span class="keyword">unsafe</span> &#123; (*ipc4hdr).dst_addr &#125;);</span><br><span class="line">    <span class="comment">// Available IPv4 parameters:</span></span><br><span class="line">    <span class="comment">// let ttl = unsafe &#123; (*ipc4hdr).ttl &#125;;         // Time To Live</span></span><br><span class="line">    <span class="comment">// let tos = unsafe &#123; (*ipc4hdr).tos &#125;;         // Type of Service</span></span><br><span class="line">    <span class="comment">// let tot_len = u16::from_be(unsafe &#123; (*ipc4hdr).tot_len &#125;); // Total Length</span></span><br><span class="line">    <span class="comment">// let id = u16::from_be(unsafe &#123; (*ipc4hdr).id &#125;);           // Identification</span></span><br><span class="line">    <span class="comment">// let frag_off = unsafe &#123; (*ipc4hdr).frag_off &#125;;             // Fragment Offset</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (source_port, dest_port) = <span class="keyword">match</span> <span class="keyword">unsafe</span> &#123; (*ipc4hdr).proto&#125; &#123;</span><br><span class="line">        IpProto::Tcp =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">tcphdr</span>: *<span class="keyword">const</span> TcpHdr = <span class="title function_ invoke__">ptr_at</span>(&amp;ctx, EthHdr::LEN + Ipv4Hdr::LEN)?;</span><br><span class="line">            <span class="comment">// Available TCP parameters:</span></span><br><span class="line">            <span class="comment">// let seq = u32::from_be(unsafe &#123; (*tcphdr).seq &#125;);     // Sequence Number</span></span><br><span class="line">            <span class="comment">// let ack = u32::from_be(unsafe &#123; (*tcphdr).ack_seq &#125;); // Acknowledgment Number</span></span><br><span class="line">            <span class="comment">// let window = u16::from_be(unsafe &#123; (*tcphdr).window &#125;); // Window Size</span></span><br><span class="line">            <span class="comment">// let flags = unsafe &#123; (*tcphdr).flags &#125;;               // TCP Flags (SYN, ACK, etc)</span></span><br><span class="line">            (</span><br><span class="line">                <span class="type">u16</span>::<span class="title function_ invoke__">from_be</span>(<span class="keyword">unsafe</span> &#123; (*tcphdr).source &#125;),</span><br><span class="line">                <span class="type">u16</span>::<span class="title function_ invoke__">from_be</span>(<span class="keyword">unsafe</span> &#123; (*tcphdr).dest &#125;)</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">        IpProto::Udp =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">udphdr</span>: *<span class="keyword">const</span> UdpHdr = <span class="title function_ invoke__">ptr_at</span>(&amp;ctx, EthHdr::LEN + Ipv4Hdr::LEN)?;</span><br><span class="line">            <span class="comment">// Available UDP parameters:</span></span><br><span class="line">            <span class="comment">// let length = u16::from_be(unsafe &#123; (*udphdr).len &#125;);  // UDP datagram length</span></span><br><span class="line">            <span class="comment">// let checksum = u16::from_be(unsafe &#123; (*udphdr).check &#125;); // Checksum</span></span><br><span class="line">            (</span><br><span class="line">                <span class="type">u16</span>::<span class="title function_ invoke__">from_be_bytes</span>(<span class="keyword">unsafe</span> &#123; (*udphdr).source &#125;),</span><br><span class="line">                <span class="type">u16</span>::<span class="title function_ invoke__">from_be_bytes</span>(<span class="keyword">unsafe</span> &#123; (*udphdr).dest &#125;)</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">        _ =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(()),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    info!(</span><br><span class="line">        &amp;ctx, </span><br><span class="line">        <span class="string">&quot;SRC IP: &#123;:i&#125;, SRC PORT: &#123;&#125;, DST IP: &#123;:i&#125;, DST PORT: &#123;&#125;&quot;</span>, </span><br><span class="line">        source_addr, </span><br><span class="line">        source_port,</span><br><span class="line">        dest_addr,</span><br><span class="line">        dest_port</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(xdp_action::XDP_PASS)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<hr>
<h2 id="Loading-and-Attaching-the-Program"><a href="#Loading-and-Attaching-the-Program" class="headerlink" title="Loading and Attaching the Program"></a>Loading and Attaching the Program</h2><p>Here’s a minimal Rust user-space loader to attach your XDP program to a network interface:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// inside inside xdp_packet_parser/xdp_packet_parser/src/main.rs</span></span><br><span class="line"><span class="keyword">use</span> anyhow::Context;</span><br><span class="line"><span class="keyword">use</span> aya::programs::&#123;Xdp, XdpFlags&#125;;</span><br><span class="line"><span class="keyword">use</span> clap::Parser;</span><br><span class="line"><span class="keyword">use</span> log::&#123;info, warn&#125;;</span><br><span class="line"><span class="keyword">use</span> tokio::signal;</span><br><span class="line"><span class="keyword">use</span> aya_log::EbpfLogger;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug, Parser)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Opt</span> &#123;</span><br><span class="line">    <span class="meta">#[clap(short, long, default_value = <span class="string">&quot;eth0&quot;</span>)]</span></span><br><span class="line">    iface: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> anyhow::<span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">opt</span> = Opt::<span class="title function_ invoke__">parse</span>();</span><br><span class="line"></span><br><span class="line">    env_logger::<span class="title function_ invoke__">init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">bpf</span> = aya::Ebpf::<span class="title function_ invoke__">load</span>(aya::include_bytes_aligned!(<span class="built_in">concat!</span>(</span><br><span class="line">        <span class="string">&quot;../../target/bpfel-unknown-none/release&quot;</span>,</span><br><span class="line">        <span class="string">&quot;/packet-logger&quot;</span></span><br><span class="line">    )))?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(e) = EbpfLogger::<span class="title function_ invoke__">init</span>(&amp;<span class="keyword">mut</span> bpf) &#123;</span><br><span class="line">        warn!(<span class="string">&quot;failed to initialize eBPF logger: &#123;&#125;&quot;</span>,e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">program</span>: &amp;<span class="keyword">mut</span> Xdp = bpf.<span class="title function_ invoke__">program_mut</span>(<span class="string">&quot;xdp_firewall&quot;</span>).<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">try_into</span>()?;</span><br><span class="line">    program.<span class="title function_ invoke__">load</span>()?;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    program.<span class="title function_ invoke__">attach</span>(&amp;opt.iface, XdpFlags::<span class="title function_ invoke__">default</span>())</span><br><span class="line">        .<span class="title function_ invoke__">context</span>(<span class="string">&quot;failed to attach the XDP program with default flags - try changing XdpFlags::default() to XdpFlags::SKB_MODE&quot;</span>)?;</span><br><span class="line"></span><br><span class="line">    info!(<span class="string">&quot;Waiting for Ctrl-C...&quot;</span>);</span><br><span class="line">    signal::<span class="title function_ invoke__">ctrl_c</span>().<span class="keyword">await</span>?;</span><br><span class="line">    info!(<span class="string">&quot;Exiting....&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li><code>iface</code> is the network interface you want to monitor (e.g., <code>eth0</code>, <code>enp2s0</code>, etc.).</li>
</ul>
<hr>
<h2 id="Building-and-Running"><a href="#Building-and-Running" class="headerlink" title="Building and Running"></a>Building and Running</h2><ol>
<li><p><strong>Build the eBPF program:</strong></p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> xdp_packet_parser/xdp_packet_parser-ebpf</span><br><span class="line">cargo +nightly build --release -Z build-std=core</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Run the user-space loader:</strong></p>
 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd xdp_packet_parser</span><br><span class="line">RUST_LOG=info sudo -E ~/.cargo/bin/cargo run -- -i &lt;network-interface&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Example: RUST_LOG=info <span class="built_in">sudo</span> -E ~/.cargo/bin/cargo run -- -i enx7e0f7f73b679</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>If you don’t see output, try a different network interface:</strong></p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip <span class="built_in">link</span> show</span><br></pre></td></tr></table></figure>

<p> This will list all available interfaces.</p>
</li>
<li><p><strong>You can also use tcpdump to see if packets are arriving:</strong></p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> tcpdump -i &lt;network-interface&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>If everything is working, you should see logs like:</strong></p>
<p> <img src="/../images/xdp_output.png" alt="alt text"></p>
</li>
</ol>
<hr>
<h2 id="Congratulations"><a href="#Congratulations" class="headerlink" title="Congratulations!"></a>Congratulations!</h2><p>You now have access to all the critical parameters from network packets at the lowest level possible.<br>From here, you can add custom logic to block, redirect, or analyze traffic—building your own high-performance network tools.</p>
<hr>
<h2 id="Follow-like-repost-comment"><a href="#Follow-like-repost-comment" class="headerlink" title="Follow ,like ,repost ,comment"></a>Follow ,like ,repost ,comment</h2><pre><code>![alt text](../images/comment.jpeg)
</code></pre>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a target="_blank" rel="noopener" href="https://ebpf.io/">eBPF Official Site</a>[2]</li>
<li><a target="_blank" rel="noopener" href="https://github.com/xdp-project/xdp-tutorial/blob/master/packet01-parsing/README.org">XDP Tutorial: Packet Parsing</a>[7]</li>
<li><a target="_blank" rel="noopener" href="https://www.tigera.io/learn/guides/ebpf/ebpf-xdp/">eBPF XDP Basics and Tutorial</a>[3]</li>
</ul>
<hr>
<p>In future blogs, we’ll continue exploring system tracers and Linux trace calls. Stay tuned!</p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/about/">About</a></li>
        
          <li><a href="/archives/">Writing</a></li>
        
          <li><a target="_blank" rel="noopener" href="https://github.com/DioBr4nd0">Projects</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#What-is-a-Network-Packet-Parser"><span class="toc-number">1.</span> <span class="toc-text">What is a Network Packet Parser?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Some-Basic-Concepts"><span class="toc-number">2.</span> <span class="toc-text">Some Basic Concepts</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%F0%9F%93%A6-What-is-a-packet"><span class="toc-number">2.1.</span> <span class="toc-text">1. 📦 What is a packet?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%F0%9F%A7%AE-What-is-an-offset"><span class="toc-number">2.2.</span> <span class="toc-text">2. 🧮 What is an offset?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%F0%9F%A7%B7-Accessing-via-pointers"><span class="toc-number">2.3.</span> <span class="toc-text">3. 🧷 Accessing via pointers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%F0%9F%A7%BE-The-packet-memory-range"><span class="toc-number">2.4.</span> <span class="toc-text">4. 🧾 The packet memory range</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-Full-Explanation-of-ptr-at"><span class="toc-number">2.5.</span> <span class="toc-text">✅ Full Explanation of ptr_at()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%92%A1-Example-Reading-the-IPv4-Header"><span class="toc-number">2.5.1.</span> <span class="toc-text">💡 Example: Reading the IPv4 Header</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%94%92-Why-all-this-checking"><span class="toc-number">2.5.2.</span> <span class="toc-text">🔒 Why all this checking?</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#What-is-XDP"><span class="toc-number">3.</span> <span class="toc-text">What is XDP?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Setting-Up-the-Codebase"><span class="toc-number">4.</span> <span class="toc-text">Setting Up the Codebase</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Main-Packet-Parsing-Logic"><span class="toc-number">5.</span> <span class="toc-text">Main Packet Parsing Logic</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Get-the-IPv4-packets-from-the-input-packet-stream"><span class="toc-number">5.1.</span> <span class="toc-text">1. Get the IPv4 packets from the input packet stream</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Extracting-and-Logging-Parameters"><span class="toc-number">5.2.</span> <span class="toc-text">2. Extracting and Logging Parameters</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-The-ptr-at-Helper"><span class="toc-number">5.3.</span> <span class="toc-text">3. The ptr_at Helper</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-The-XDP-Firewall-Entry-Point"><span class="toc-number">5.4.</span> <span class="toc-text">4. The XDP Firewall Entry Point</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Putting-It-All-Together"><span class="toc-number">5.5.</span> <span class="toc-text">5. Putting It All Together</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Loading-and-Attaching-the-Program"><span class="toc-number">6.</span> <span class="toc-text">Loading and Attaching the Program</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Building-and-Running"><span class="toc-number">7.</span> <span class="toc-text">Building and Running</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Congratulations"><span class="toc-number">8.</span> <span class="toc-text">Congratulations!</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Follow-like-repost-comment"><span class="toc-number">9.</span> <span class="toc-text">Follow ,like ,repost ,comment</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#References"><span class="toc-number">10.</span> <span class="toc-text">References</span></a></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://diobr4nd0.github.io/2025/06/27/Understanding-Network-Packet-Offsets-Safe-Parsing-in-eBPF/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://diobr4nd0.github.io/2025/06/27/Understanding-Network-Packet-Offsets-Safe-Parsing-in-eBPF/&text=Understanding Network Packet Offsets &amp; Safe Parsing in eBPF"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://diobr4nd0.github.io/2025/06/27/Understanding-Network-Packet-Offsets-Safe-Parsing-in-eBPF/&title=Understanding Network Packet Offsets &amp; Safe Parsing in eBPF"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://diobr4nd0.github.io/2025/06/27/Understanding-Network-Packet-Offsets-Safe-Parsing-in-eBPF/&is_video=false&description=Understanding Network Packet Offsets &amp; Safe Parsing in eBPF"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Understanding Network Packet Offsets &amp; Safe Parsing in eBPF&body=Check out this article: https://diobr4nd0.github.io/2025/06/27/Understanding-Network-Packet-Offsets-Safe-Parsing-in-eBPF/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://diobr4nd0.github.io/2025/06/27/Understanding-Network-Packet-Offsets-Safe-Parsing-in-eBPF/&title=Understanding Network Packet Offsets &amp; Safe Parsing in eBPF"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://diobr4nd0.github.io/2025/06/27/Understanding-Network-Packet-Offsets-Safe-Parsing-in-eBPF/&title=Understanding Network Packet Offsets &amp; Safe Parsing in eBPF"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://diobr4nd0.github.io/2025/06/27/Understanding-Network-Packet-Offsets-Safe-Parsing-in-eBPF/&title=Understanding Network Packet Offsets &amp; Safe Parsing in eBPF"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://diobr4nd0.github.io/2025/06/27/Understanding-Network-Packet-Offsets-Safe-Parsing-in-eBPF/&title=Understanding Network Packet Offsets &amp; Safe Parsing in eBPF"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://diobr4nd0.github.io/2025/06/27/Understanding-Network-Packet-Offsets-Safe-Parsing-in-eBPF/&name=Understanding Network Packet Offsets &amp; Safe Parsing in eBPF&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://diobr4nd0.github.io/2025/06/27/Understanding-Network-Packet-Offsets-Safe-Parsing-in-eBPF/&t=Understanding Network Packet Offsets &amp; Safe Parsing in eBPF"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2025
    Rupesh Prajapati
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="https://github.com/DioBr4nd0">Projects</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
