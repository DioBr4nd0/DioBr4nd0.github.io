<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="This blog post explains how to track Linux system calls (read, write, and open) using Rust and eBPF (extended Berkeley Packet Filter). We will walk through the entire process—from basic definitions, s">
<meta property="og:type" content="article">
<meta property="og:title" content="Track Linux Syscalls with Rust and eBPF">
<meta property="og:url" content="https://diobr4nd0.github.io/2025/06/21/Track-Linux-Syscalls-with-Rust-and-eBPF/index.html">
<meta property="og:site_name" content="Dio&#39;s Blogs">
<meta property="og:description" content="This blog post explains how to track Linux system calls (read, write, and open) using Rust and eBPF (extended Berkeley Packet Filter). We will walk through the entire process—from basic definitions, s">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://diobr4nd0.github.io/images/ebpf_logger_output.png">
<meta property="article:published_time" content="2025-06-20T19:15:35.000Z">
<meta property="article:modified_time" content="2025-06-20T20:03:51.401Z">
<meta property="article:author" content="Rupesh Prajapati">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://diobr4nd0.github.io/images/ebpf_logger_output.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>Track Linux Syscalls with Rust and eBPF</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 7.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="https://github.com/DioBr4nd0">Projects</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/2025/06/27/Understanding-Network-Packet-Offsets-Safe-Parsing-in-eBPF/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/2025/06/18/eBPF-A-Beginner%E2%80%99s-Guide-to-the-Future-of-Kernel-Programming/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://diobr4nd0.github.io/2025/06/21/Track-Linux-Syscalls-with-Rust-and-eBPF/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://diobr4nd0.github.io/2025/06/21/Track-Linux-Syscalls-with-Rust-and-eBPF/&text=Track Linux Syscalls with Rust and eBPF"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://diobr4nd0.github.io/2025/06/21/Track-Linux-Syscalls-with-Rust-and-eBPF/&title=Track Linux Syscalls with Rust and eBPF"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://diobr4nd0.github.io/2025/06/21/Track-Linux-Syscalls-with-Rust-and-eBPF/&is_video=false&description=Track Linux Syscalls with Rust and eBPF"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Track Linux Syscalls with Rust and eBPF&body=Check out this article: https://diobr4nd0.github.io/2025/06/21/Track-Linux-Syscalls-with-Rust-and-eBPF/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://diobr4nd0.github.io/2025/06/21/Track-Linux-Syscalls-with-Rust-and-eBPF/&title=Track Linux Syscalls with Rust and eBPF"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://diobr4nd0.github.io/2025/06/21/Track-Linux-Syscalls-with-Rust-and-eBPF/&title=Track Linux Syscalls with Rust and eBPF"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://diobr4nd0.github.io/2025/06/21/Track-Linux-Syscalls-with-Rust-and-eBPF/&title=Track Linux Syscalls with Rust and eBPF"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://diobr4nd0.github.io/2025/06/21/Track-Linux-Syscalls-with-Rust-and-eBPF/&title=Track Linux Syscalls with Rust and eBPF"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://diobr4nd0.github.io/2025/06/21/Track-Linux-Syscalls-with-Rust-and-eBPF/&name=Track Linux Syscalls with Rust and eBPF&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://diobr4nd0.github.io/2025/06/21/Track-Linux-Syscalls-with-Rust-and-eBPF/&t=Track Linux Syscalls with Rust and eBPF"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Basic-Definitions"><span class="toc-number">1.</span> <span class="toc-text">Basic Definitions</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Installation-Steps"><span class="toc-number">1.1.</span> <span class="toc-text">Installation Steps</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Setting-Up-the-Codebase"><span class="toc-number">2.</span> <span class="toc-text">Setting Up the Codebase</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Project-Structure-Overview"><span class="toc-number">3.</span> <span class="toc-text">Project Structure Overview</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Writing-the-eBPF-Program-Logic"><span class="toc-number">4.</span> <span class="toc-text">Writing the eBPF Program Logic</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Creating-a-Map-to-Store-Syscall-Counts"><span class="toc-number">4.1.</span> <span class="toc-text">1. Creating a Map to Store Syscall Counts</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Defining-Counter-Functions-for-Each-Syscall"><span class="toc-number">4.2.</span> <span class="toc-text">2. Defining Counter Functions for Each Syscall</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Incrementing-Syscall-Counts"><span class="toc-number">4.3.</span> <span class="toc-text">3. Incrementing Syscall Counts</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Panic-Handler-in-eBPF"><span class="toc-number">4.4.</span> <span class="toc-text">4. Panic Handler in eBPF</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Complete-eBPF-Program-Code"><span class="toc-number">4.5.</span> <span class="toc-text">5. Complete eBPF Program Code</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Building-the-eBPF-Program"><span class="toc-number">5.</span> <span class="toc-text">Building the eBPF Program</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Writing-the-User-Space-Rust-Program"><span class="toc-number">6.</span> <span class="toc-text">Writing the User-Space Rust Program</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Running-the-Program"><span class="toc-number">6.1.</span> <span class="toc-text">2. Running the Program</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Next-Steps"><span class="toc-number">7.</span> <span class="toc-text">Next Steps</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#References"><span class="toc-number">8.</span> <span class="toc-text">References</span></a></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        Track Linux Syscalls with Rust and eBPF
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">Rupesh Prajapati</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2025-06-20T19:15:35.000Z" class="dt-published" itemprop="datePublished">2025-06-21</time>
        
      
    </div>


      

      

    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <p>This blog post explains how to track Linux system calls (<code>read</code>, <code>write</code>, and <code>open</code>) using Rust and eBPF (extended Berkeley Packet Filter). We will walk through the entire process—from basic definitions, setting up the project, writing eBPF programs, to loading and running them in user space with Rust. The goal is to provide a clear, beginner-friendly guide with well-structured explanations and code examples.</p>
<hr>
<h2 id="Basic-Definitions"><a href="#Basic-Definitions" class="headerlink" title="Basic Definitions"></a>Basic Definitions</h2><p>Before diving into the code, let’s clarify some key concepts:</p>
<ul>
<li><strong>Syscall (System Call):</strong> A mechanism used by programs to request services from the kernel, such as reading or writing files.</li>
<li><strong>read calls:</strong> System calls that read data from a file descriptor.</li>
<li><strong>write calls:</strong> System calls that write data to a file descriptor.</li>
<li><strong>open calls:</strong> System calls that open files or devices.</li>
<li><strong>Kprobe:</strong> A kernel feature that allows attaching custom handlers to almost any kernel function entry point.</li>
<li><strong>kretprobe:</strong> Similar to kprobe but attaches to function return points.</li>
<li><strong>User space:</strong> The memory space where user applications run.</li>
<li><strong>Kernel space:</strong> The protected memory space where the operating system kernel runs.</li>
</ul>
<hr>
<h3 id="Installation-Steps"><a href="#Installation-Steps" class="headerlink" title="Installation Steps"></a><strong>Installation Steps</strong></h3><ol>
<li><p><strong>Install Essential Build Tools, LLVM, and Clang</strong><br>eBPF programs are typically compiled with LLVM and Clang. You can install these along with other essential build tools using your distribution’s package manager. For Debian&#x2F;Ubuntu systems, run:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install -y build-essential llvm clang</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Install Rust using <code>rustup</code></strong><br>The recommended way to install Rust is with <code>rustup</code>, the official toolchain manager. It manages your Rust versions and associated tools.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --proto <span class="string">&#x27;=https&#x27;</span> --tlsv1.2 -sSf https://sh.rustup.rs | sh</span><br></pre></td></tr></table></figure>
<p>Follow the on-screen prompts, choosing the default installation is usually sufficient. After installation, make sure to configure your current shell by running <code>source &quot;$HOME/.cargo/env&quot;</code>.</p>
</li>
<li><p><strong>Install the Rust Nightly Toolchain</strong><br>The Aya library, which we’ll be using, requires features that are only available in the nightly version of Rust. Install it alongside your stable toolchain:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rustup install nightly</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Install <code>cargo-generate</code></strong><br>We will use <code>cargo-generate</code> to create a new project from the official Aya template. This makes bootstrapping a new eBPF project much easier.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo install cargo-generate</span><br></pre></td></tr></table></figure></li>
</ol>
<p>With the environment now set up, you are ready to create your first eBPF project.</p>
<hr>
<h2 id="Setting-Up-the-Codebase"><a href="#Setting-Up-the-Codebase" class="headerlink" title="Setting Up the Codebase"></a>Setting Up the Codebase</h2><p>To start, follow the Rust eBPF development setup instructions provided by the Aya project:</p>
<ol>
<li><p>Generate a new eBPF project template:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo generate -a aya-rs/aya-template -n syscall_ebpf</span><br></pre></td></tr></table></figure>

<p>During the prompts:</p>
<ul>
<li>Select <strong>kprobe</strong> as the type of eBPF program.</li>
<li>Attach the kprobe to <code>__x64_sys_open</code> syscall (you will add others later).</li>
</ul>
</li>
</ol>
<hr>
<h2 id="Project-Structure-Overview"><a href="#Project-Structure-Overview" class="headerlink" title="Project Structure Overview"></a>Project Structure Overview</h2><p>The generated project will have three main parts:</p>
<ul>
<li><code>syscall_ebpf</code>: Contains the main Rust code for user-space logging and interaction.</li>
<li><code>syscall_ebpf_common</code>: Defines shared data structures between user and kernel space.</li>
<li><code>syscall_ebpf-ebpf</code>: Contains the eBPF program logic running inside the kernel.</li>
</ul>
<hr>
<h2 id="Writing-the-eBPF-Program-Logic"><a href="#Writing-the-eBPF-Program-Logic" class="headerlink" title="Writing the eBPF Program Logic"></a>Writing the eBPF Program Logic</h2><h3 id="1-Creating-a-Map-to-Store-Syscall-Counts"><a href="#1-Creating-a-Map-to-Store-Syscall-Counts" class="headerlink" title="1. Creating a Map to Store Syscall Counts"></a>1. Creating a Map to Store Syscall Counts</h3><p>We use a <code>HashMap</code> in eBPF to keep track of how many times each syscall is called.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In syscall_ebpf-ebpf/src/main.rs</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Define a map with up to 10 entries to store counts keyed by syscall ID</span></span><br><span class="line"><span class="meta">#[map]</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> SYSCALL_COUNTS: HashMap&lt;<span class="type">u32</span>, <span class="type">u64</span>&gt; = HashMap::&lt;<span class="type">u32</span>, <span class="type">u64</span>&gt;::<span class="title function_ invoke__">with_max_entries</span>(<span class="number">10</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>The <code>#[map]</code> macro declares this map for eBPF to manage in kernel space.</p>
<h3 id="2-Defining-Counter-Functions-for-Each-Syscall"><a href="#2-Defining-Counter-Functions-for-Each-Syscall" class="headerlink" title="2. Defining Counter Functions for Each Syscall"></a>2. Defining Counter Functions for Each Syscall</h3><p>We attach kprobes to syscall entry points and increment counters accordingly. We assign arbitrary IDs for our syscalls:</p>
<ul>
<li><code>0</code> for <code>read</code></li>
<li><code>1</code> for <code>write</code></li>
<li><code>2</code> for <code>open</code></li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In syscall_ebpf-ebpf/src/main.rs</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[kprobe]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">read_counter</span>(ctx: ProbeContext) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">increment_syscall_count</span>(&amp;ctx, <span class="number">0</span>); <span class="comment">// ID 0 for read</span></span><br><span class="line">    <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[kprobe]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">write_counter</span>(ctx: ProbeContext) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">increment_syscall_count</span>(&amp;ctx, <span class="number">1</span>); <span class="comment">// ID 1 for write</span></span><br><span class="line">    <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[kprobe]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">open_counter</span>(ctx: ProbeContext) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">increment_syscall_count</span>(&amp;ctx, <span class="number">2</span>); <span class="comment">// ID 2 for open</span></span><br><span class="line">    <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-Incrementing-Syscall-Counts"><a href="#3-Incrementing-Syscall-Counts" class="headerlink" title="3. Incrementing Syscall Counts"></a>3. Incrementing Syscall Counts</h3><p>This helper function updates the count for the given syscall ID.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In syscall_ebpf-ebpf/src/main.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">increment_syscall_count</span>(ctx: &amp;ProbeContext, syscall_id: <span class="type">u32</span>) &#123;</span><br><span class="line"><span class="keyword">unsafe</span> &#123;</span><br><span class="line"><span class="comment">// Get a mutable pointer to the count for the given syscall_id.</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">count</span> = SYSCALL_COUNTS.<span class="title function_ invoke__">get_ptr_mut</span>(&amp;syscall_id);</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(count) = count &#123;</span><br><span class="line">        <span class="comment">// If the key exists, increment the count.</span></span><br><span class="line">        *count += <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// If the key doesn&#x27;t exist, insert a new entry with count 1.</span></span><br><span class="line">        <span class="comment">// The unwrap_or_else is a simple way to handle potential errors on insertion.</span></span><br><span class="line">        SYSCALL_COUNTS.<span class="title function_ invoke__">insert</span>(&amp;syscall_id, &amp;<span class="number">1</span>, <span class="number">0</span>).<span class="title function_ invoke__">unwrap_or_else</span>(|_| ());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Log that a syscall was called, including its ID and the Process ID (PID).</span></span><br><span class="line">    info!(ctx, <span class="string">&quot;Syscall &#123;&#125; called by PID &#123;&#125;&quot;</span>, syscall_id, <span class="title function_ invoke__">bpf_get_current_pid_tgid</span>() &gt;&gt; <span class="number">32</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>We fetch a mutable pointer to the current count.</li>
<li>If it exists, we increment it; otherwise, we insert an initial count of <code>1</code>.</li>
<li>We log the syscall ID and the calling process’s PID for real-time visibility.</li>
</ul>
<h3 id="4-Panic-Handler-in-eBPF"><a href="#4-Panic-Handler-in-eBPF" class="headerlink" title="4. Panic Handler in eBPF"></a>4. Panic Handler in eBPF</h3><p>eBPF programs cannot unwind on panic, so we must provide a minimal handler that loops forever.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(not(test))]</span></span><br><span class="line"><span class="meta">#[panic_handler]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">panic</span>(_info: &amp;core::panic::PanicInfo) <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="keyword">loop</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5-Complete-eBPF-Program-Code"><a href="#5-Complete-eBPF-Program-Code" class="headerlink" title="5. Complete eBPF Program Code"></a>5. Complete eBPF Program Code</h3><p>Here is the full source code for <code>syscall_ebpf-ebpf/src/main.rs</code>:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![no_std]</span></span><br><span class="line"><span class="meta">#![no_main]</span></span><br><span class="line"><span class="meta">#![allow(warnings)]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> aya_ebpf::&#123;macros::kprobe, programs::ProbeContext, helpers::bpf_get_current_pid_tgid&#125;;</span><br><span class="line"><span class="keyword">use</span> aya_log_ebpf::info;</span><br><span class="line"><span class="keyword">use</span> aya_ebpf::maps::HashMap;</span><br><span class="line"><span class="keyword">use</span> aya_ebpf::macros::map;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[map]</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> SYSCALL_COUNTS: HashMap&lt;<span class="type">u32</span>, <span class="type">u64</span>&gt; = HashMap::&lt;<span class="type">u32</span>,<span class="type">u64</span>&gt;::<span class="title function_ invoke__">with_max_entries</span>(<span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">increment_syscall_count</span>(ctx: &amp;ProbeContext, syscall_id:<span class="type">u32</span>) &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">count</span> = SYSCALL_COUNTS.<span class="title function_ invoke__">get_ptr_mut</span>(&amp;syscall_id);</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(count) =count &#123;</span><br><span class="line">            *count +=<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            SYSCALL_COUNTS.<span class="title function_ invoke__">insert</span>(&amp;syscall_id, &amp;<span class="number">1</span>, <span class="number">0</span>).<span class="title function_ invoke__">unwrap_or_else</span>(|_| ());</span><br><span class="line">        &#125;</span><br><span class="line">        info!(ctx,<span class="string">&quot;Syscall &#123;&#125; called by PID &#123;&#125;&quot;</span>,syscall_id, <span class="title function_ invoke__">bpf_get_current_pid_tgid</span>()&gt;&gt;<span class="number">32</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#[kprobe]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">read_counter</span>(ctx: ProbeContext) <span class="punctuation">-&gt;</span> <span class="type">u32</span>&#123;</span><br><span class="line">    <span class="comment">// Use &#x27;0&#x27; as an arbitrary ID for the &#x27;read&#x27; syscall</span></span><br><span class="line">    <span class="title function_ invoke__">increment_syscall_count</span>(&amp;ctx, <span class="number">0</span>);</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[kprobe]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">write_counter</span>(ctx: ProbeContext) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">     <span class="comment">// Use &#x27;1&#x27; as an arbitrary ID for the &#x27;write&#x27; syscall</span></span><br><span class="line">    <span class="title function_ invoke__">increment_syscall_count</span>(&amp;ctx, <span class="number">1</span>);</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[kprobe]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">open_counter</span>(ctx: ProbeContext) <span class="punctuation">-&gt;</span> <span class="type">u32</span>&#123;</span><br><span class="line">      <span class="comment">// Use &#x27;2&#x27; as an arbitrary ID for the &#x27;open&#x27; syscall</span></span><br><span class="line">    <span class="title function_ invoke__">increment_syscall_count</span>(&amp;ctx, <span class="number">2</span>);</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(not(test))]</span></span><br><span class="line"><span class="meta">#[panic_handler]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">panic</span>(_info: &amp;core::panic::PanicInfo) <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="keyword">loop</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[link_section = <span class="string">&quot;license&quot;</span>]</span></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">static</span> LICENSE: [<span class="type">u8</span>; <span class="number">13</span>] = *<span class="string">b&quot;Dual MIT/GPL\0&quot;</span>;</span><br></pre></td></tr></table></figure>


<hr>
<h2 id="Building-the-eBPF-Program"><a href="#Building-the-eBPF-Program" class="headerlink" title="Building the eBPF Program"></a>Building the eBPF Program</h2><p>Create a <code>.cargo/config.toml</code> file inside the <code>syscall_ebpf-ebpf</code> directory with the following content to target the eBPF architecture:</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[build]</span></span><br><span class="line"><span class="attr">target</span> = <span class="string">&quot;bpfel-unknown-none&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[target.bpfel-unknown-none]</span></span><br><span class="line"><span class="attr">rustflags</span> = [<span class="string">&quot;-C&quot;</span>, <span class="string">&quot;panic=abort&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>Then build the program using the nightly toolchain:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo +nightly build --release -Z build-std=core</span><br></pre></td></tr></table></figure>


<hr>
<h2 id="Writing-the-User-Space-Rust-Program"><a href="#Writing-the-User-Space-Rust-Program" class="headerlink" title="Writing the User-Space Rust Program"></a>Writing the User-Space Rust Program</h2><p>This program loads the eBPF bytecode, attaches the kprobes to the kernel functions, and periodically reads the syscall counts from the eBPF map to display them.</p>
<p>Here is the complete code for <code>syscall_ebpf/src/main.rs</code>:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// syscall_ebpf/src/main.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> anyhow::&#123;anyhow, Context&#125;; <span class="comment">// Import Context for the .context() method</span></span><br><span class="line"><span class="keyword">use</span> aya::maps::HashMap;</span><br><span class="line"><span class="keyword">use</span> aya::programs::KProbe;</span><br><span class="line"><span class="keyword">use</span> aya::&#123;include_bytes_aligned, Ebpf&#125;; <span class="comment">// Use modern `Ebpf` type</span></span><br><span class="line"><span class="keyword">use</span> aya_log::EbpfLogger; <span class="comment">// Use modern `EbpfLogger` type</span></span><br><span class="line"><span class="keyword">use</span> log::&#123;info, warn&#125;;</span><br><span class="line"><span class="keyword">use</span> tokio::signal;</span><br><span class="line"><span class="keyword">use</span> tokio::time::&#123;<span class="keyword">self</span>, Duration&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), anyhow::Error&gt; &#123;</span><br><span class="line">    <span class="comment">// This part loads the eBPF bytecode. It requires the file to exist.</span></span><br><span class="line">    <span class="comment">// The conditional compilation (`#[cfg]`) handles both debug and release builds.</span></span><br><span class="line">    <span class="meta">#[cfg(debug_assertions)]</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">bpf</span> = Ebpf::<span class="title function_ invoke__">load</span>(include_bytes_aligned!(</span><br><span class="line">        <span class="string">&quot;../../target/bpfel-unknown-none/release/syscall_ebpf&quot;</span></span><br><span class="line">    ))?;</span><br><span class="line">    <span class="meta">#[cfg(not(debug_assertions))]</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">bpf</span> = Ebpf::<span class="title function_ invoke__">load</span>(include_bytes_aligned!(</span><br><span class="line">        <span class="string">&quot;../../target/bpfel-unknown-none/release/syscall_ebpf&quot;</span></span><br><span class="line">    ))?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(e) = EbpfLogger::<span class="title function_ invoke__">init</span>(&amp;<span class="keyword">mut</span> bpf) &#123;</span><br><span class="line">        warn!(<span class="string">&quot;failed to initialize eBPF logger: &#123;&#125;&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Attach to the &#x27;read&#x27; syscall</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">read_prog</span>: &amp;<span class="keyword">mut</span> KProbe = bpf.<span class="title function_ invoke__">program_mut</span>(<span class="string">&quot;read_counter&quot;</span>).<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">try_into</span>()?;</span><br><span class="line">    read_prog.<span class="title function_ invoke__">load</span>()?;</span><br><span class="line">    read_prog.<span class="title function_ invoke__">attach</span>(<span class="string">&quot;__x64_sys_read&quot;</span>, <span class="number">0</span>)?;</span><br><span class="line">    info!(<span class="string">&quot;Attached kprobe to __x64_sys_read&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Attach to the &#x27;write&#x27; syscall</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">write_prog</span>: &amp;<span class="keyword">mut</span> KProbe = bpf.<span class="title function_ invoke__">program_mut</span>(<span class="string">&quot;write_counter&quot;</span>).<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">try_into</span>()?;</span><br><span class="line">    write_prog.<span class="title function_ invoke__">load</span>()?;</span><br><span class="line">    write_prog.<span class="title function_ invoke__">attach</span>(<span class="string">&quot;__x64_sys_write&quot;</span>, <span class="number">0</span>)?;</span><br><span class="line">    info!(<span class="string">&quot;Attached kprobe to __x64_sys_write&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Attach to the &#x27;open&#x27; syscall</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">open_prog</span>: &amp;<span class="keyword">mut</span> KProbe = bpf.<span class="title function_ invoke__">program_mut</span>(<span class="string">&quot;open_counter&quot;</span>).<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">try_into</span>()?;</span><br><span class="line">    open_prog.<span class="title function_ invoke__">load</span>()?;</span><br><span class="line">    open_prog.<span class="title function_ invoke__">attach</span>(<span class="string">&quot;__x64_sys_open&quot;</span>, <span class="number">0</span>)?;</span><br><span class="line">    info!(<span class="string">&quot;Attached kprobe to __x64_sys_open&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// **FIXED LINE:** Convert the Option from map_mut() into a Result using .context()</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">counts_map_generic</span> = bpf</span><br><span class="line">        .<span class="title function_ invoke__">map_mut</span>(<span class="string">&quot;SYSCALL_COUNTS&quot;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">context</span>(<span class="string">&quot;Failed to find the SYSCALL_COUNTS map&quot;</span>)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">counts_map</span>: HashMap&lt;_, <span class="type">u32</span>, <span class="type">u64</span>&gt; = HashMap::<span class="title function_ invoke__">try_from</span>(counts_map_generic)?;</span><br><span class="line"></span><br><span class="line">    info!(<span class="string">&quot;Waiting for Ctrl-C to exit...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">interval</span> = time::<span class="title function_ invoke__">interval</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        tokio::<span class="built_in">select!</span> &#123;</span><br><span class="line">            _ = interval.<span class="title function_ invoke__">tick</span>() =&gt; &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">read_count</span> = counts_map.<span class="title function_ invoke__">get</span>(&amp;<span class="number">0</span>, <span class="number">0</span>).<span class="title function_ invoke__">unwrap_or</span>(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">write_count</span> = counts_map.<span class="title function_ invoke__">get</span>(&amp;<span class="number">1</span>, <span class="number">0</span>).<span class="title function_ invoke__">unwrap_or</span>(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">open_count</span> = counts_map.<span class="title function_ invoke__">get</span>(&amp;<span class="number">2</span>, <span class="number">0</span>).<span class="title function_ invoke__">unwrap_or</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;---------------------------------&quot;</span>);</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;Read calls:  &#123;&#125;&quot;</span>, read_count);</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;Write calls: &#123;&#125;&quot;</span>, write_count);</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;Open calls:  &#123;&#125;&quot;</span>, open_count);</span><br><span class="line">            &#125;</span><br><span class="line">            _ = signal::<span class="title function_ invoke__">ctrl_c</span>() =&gt; &#123;</span><br><span class="line">                info!(<span class="string">&quot;Exiting...&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-Running-the-Program"><a href="#2-Running-the-Program" class="headerlink" title="2. Running the Program"></a>2. Running the Program</h3><p>Run the user-space program with elevated privileges and specify your network interface (replace <code>enp2s0</code> with your interface):</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUST_LOG=info <span class="built_in">sudo</span> -E cargo run -- -i enp2s0</span><br></pre></td></tr></table></figure>


<p>You should see output similar to:</p>
<p> <img src="/../images/ebpf_logger_output.png" alt="alt text"></p>
<hr>
<h2 id="Next-Steps"><a href="#Next-Steps" class="headerlink" title="Next Steps"></a>Next Steps</h2><p>This example demonstrates a simple but powerful way to track syscalls with Rust and eBPF. You can extend this foundation to:</p>
<ul>
<li>Parse and analyze network packets.</li>
<li>Use tracepoints for more detailed kernel events.</li>
<li>Build custom logging and monitoring tools for security or performance analysis.</li>
</ul>
<p>Stay tuned for more advanced eBPF tutorials!</p>
<hr>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a target="_blank" rel="noopener" href="https://aya-rs.dev/">Aya eBPF Rust Library</a></li>
<li><a target="_blank" rel="noopener" href="https://www.kernel.org/doc/html/latest/trace/kprobes.html">Linux Kernel Kprobes Documentation</a></li>
<li><a target="_blank" rel="noopener" href="https://aya-rs.dev/book/start/development/">Rust eBPF Development Guide</a></li>
</ul>
<hr>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/about/">About</a></li>
        
          <li><a href="/archives/">Writing</a></li>
        
          <li><a target="_blank" rel="noopener" href="https://github.com/DioBr4nd0">Projects</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Basic-Definitions"><span class="toc-number">1.</span> <span class="toc-text">Basic Definitions</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Installation-Steps"><span class="toc-number">1.1.</span> <span class="toc-text">Installation Steps</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Setting-Up-the-Codebase"><span class="toc-number">2.</span> <span class="toc-text">Setting Up the Codebase</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Project-Structure-Overview"><span class="toc-number">3.</span> <span class="toc-text">Project Structure Overview</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Writing-the-eBPF-Program-Logic"><span class="toc-number">4.</span> <span class="toc-text">Writing the eBPF Program Logic</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Creating-a-Map-to-Store-Syscall-Counts"><span class="toc-number">4.1.</span> <span class="toc-text">1. Creating a Map to Store Syscall Counts</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Defining-Counter-Functions-for-Each-Syscall"><span class="toc-number">4.2.</span> <span class="toc-text">2. Defining Counter Functions for Each Syscall</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Incrementing-Syscall-Counts"><span class="toc-number">4.3.</span> <span class="toc-text">3. Incrementing Syscall Counts</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Panic-Handler-in-eBPF"><span class="toc-number">4.4.</span> <span class="toc-text">4. Panic Handler in eBPF</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Complete-eBPF-Program-Code"><span class="toc-number">4.5.</span> <span class="toc-text">5. Complete eBPF Program Code</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Building-the-eBPF-Program"><span class="toc-number">5.</span> <span class="toc-text">Building the eBPF Program</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Writing-the-User-Space-Rust-Program"><span class="toc-number">6.</span> <span class="toc-text">Writing the User-Space Rust Program</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Running-the-Program"><span class="toc-number">6.1.</span> <span class="toc-text">2. Running the Program</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Next-Steps"><span class="toc-number">7.</span> <span class="toc-text">Next Steps</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#References"><span class="toc-number">8.</span> <span class="toc-text">References</span></a></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://diobr4nd0.github.io/2025/06/21/Track-Linux-Syscalls-with-Rust-and-eBPF/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://diobr4nd0.github.io/2025/06/21/Track-Linux-Syscalls-with-Rust-and-eBPF/&text=Track Linux Syscalls with Rust and eBPF"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://diobr4nd0.github.io/2025/06/21/Track-Linux-Syscalls-with-Rust-and-eBPF/&title=Track Linux Syscalls with Rust and eBPF"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://diobr4nd0.github.io/2025/06/21/Track-Linux-Syscalls-with-Rust-and-eBPF/&is_video=false&description=Track Linux Syscalls with Rust and eBPF"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Track Linux Syscalls with Rust and eBPF&body=Check out this article: https://diobr4nd0.github.io/2025/06/21/Track-Linux-Syscalls-with-Rust-and-eBPF/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://diobr4nd0.github.io/2025/06/21/Track-Linux-Syscalls-with-Rust-and-eBPF/&title=Track Linux Syscalls with Rust and eBPF"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://diobr4nd0.github.io/2025/06/21/Track-Linux-Syscalls-with-Rust-and-eBPF/&title=Track Linux Syscalls with Rust and eBPF"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://diobr4nd0.github.io/2025/06/21/Track-Linux-Syscalls-with-Rust-and-eBPF/&title=Track Linux Syscalls with Rust and eBPF"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://diobr4nd0.github.io/2025/06/21/Track-Linux-Syscalls-with-Rust-and-eBPF/&title=Track Linux Syscalls with Rust and eBPF"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://diobr4nd0.github.io/2025/06/21/Track-Linux-Syscalls-with-Rust-and-eBPF/&name=Track Linux Syscalls with Rust and eBPF&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://diobr4nd0.github.io/2025/06/21/Track-Linux-Syscalls-with-Rust-and-eBPF/&t=Track Linux Syscalls with Rust and eBPF"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2025
    Rupesh Prajapati
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="https://github.com/DioBr4nd0">Projects</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
